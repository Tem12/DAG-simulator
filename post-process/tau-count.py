import argparse
import random
import networkx as nx
from tqdm import tqdm
import matplotlib.pyplot as plt
import statistics

# Traverse graph from node X to node Y from all nodes stored in configuration. Do this process n times for groups where:
# nodes are badly connected (1 - 2 connections)
# nodes are commonly connected (3 - 12 connections)
# nodes are very well connected (12 - 100 connections)
# For each shortest path output following data:
#   - Number of hops
#   - Network propagation time (Tau)
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--config', type=str, required=True,
                        help='Data file generated by simulation')

    args = parser.parse_args()

    G = nx.Graph()

    with open(args.config, 'r') as metadata_file:
         for row in metadata_file:
            value = row.rstrip('\n')
            if value[:10] == 'biconnect=':
                rowStr = value[10:].split(' ')
                node1 = int(rowStr[0])
                node2 = int(rowStr[1])
                delay = int(rowStr[2])

                if node1 not in G.nodes:
                    G.add_node(node1)
                
                if node2 not in G.nodes:
                    G.add_node(node2)
                
                G.add_edge(node1, node2, weight=delay)

    bad_connected_nodes = []
    common_connected_nodes = []
    well_connected_nodes = []

    for i in list(G.nodes):
        num_of_connections = len(list(nx.neighbors(G, i)))
        if num_of_connections >= 1 and num_of_connections <= 4:
            bad_connected_nodes.append(i)
        elif num_of_connections >= 5 and num_of_connections <= 12:
            common_connected_nodes.append(i)
        else:
            well_connected_nodes.append(i)

    # print(len(bad_connected_nodes))
    # print(len(common_connected_nodes))
    # print(len(well_connected_nodes))

    n = 1000
    all_hops = []
    all_tau = []
    for _ in tqdm(range(0, n)):
        hops, tau = traverse_graph(G, range(len(G.nodes)))
        all_hops.append(hops)
        all_tau.append(tau)

    print('[All] Min number of hops:', min(all_hops))
    print('[All] Min tau:', min(all_tau) / 1000, 'secs')
    print('[All] Max number of hops:', max(all_hops))
    print('[All] Max tau:', max(all_tau) / 1000, 'secs')
    print('[All] Standard deviation hops:', statistics.stdev(all_hops))
    print('[All] Standard deviation tau:', statistics.stdev(all_tau) / 1000, 'secs')
    print('[All] Average number of hops:', sum(all_hops) / len(all_hops))
    print('[All] Average tau:', sum(all_tau) / len(all_tau) / 1000, 'secs')

    # =============================================================
    all_hops.clear()
    all_tau.clear()
    for _ in tqdm(range(0, n)):
        hops, tau = traverse_graph(G, bad_connected_nodes)
        all_hops.append(hops)
        all_tau.append(tau)

    print('[Bad] Min number of hops:', min(all_hops))
    print('[Bad] Min tau:', min(all_tau) / 1000, 'secs')
    print('[Bad] Max number of hops:', max(all_hops))
    print('[Bad] Max tau:', max(all_tau) / 1000, 'secs')
    print('[Bad] Standard deviation hops:', statistics.stdev(all_hops))
    print('[Bad] Standard deviation tau:', statistics.stdev(all_tau) / 1000, 'secs')
    print('[Bad] Average number of hops:', sum(all_hops) / len(all_hops))
    print('[Bad] Average tau:', sum(all_tau) / len(all_tau) / 1000, 'secs')

    # =============================================================
    all_hops.clear()
    all_tau.clear()
    for _ in tqdm(range(0, n)):
        hops, tau = traverse_graph(G, common_connected_nodes)
        all_hops.append(hops)
        all_tau.append(tau)

    print('[Common] Min number of hops:', min(all_hops))
    print('[Common] Min tau:', min(all_tau) / 1000, 'secs')
    print('[Common] Max number of hops:', max(all_hops))
    print('[Common] Max tau:', max(all_tau) / 1000, 'secs')
    print('[Common] Standard deviation hops:', statistics.stdev(all_hops))
    print('[Common] Standard deviation tau:', statistics.stdev(all_tau) / 1000, 'secs')
    print('[Common] Average number of hops:', sum(all_hops) / len(all_hops))
    print('[Common] Average tau:', sum(all_tau) / len(all_tau) / 1000, 'secs')

    # =============================================================
    all_hops.clear()
    all_tau.clear()
    for _ in tqdm(range(0, n)):
        hops, tau = traverse_graph(G, well_connected_nodes)
        all_hops.append(hops)
        all_tau.append(tau)

    print('[Well] Min number of hops:', min(all_hops))
    print('[Well] Min tau:', min(all_tau) / 1000, 'secs')
    print('[Well] Max number of hops:', max(all_hops))
    print('[Well] Max tau:', max(all_tau) / 1000, 'secs')
    print('[Well] Standard deviation hops:', statistics.stdev(all_hops))
    print('[Well] Standard deviation tau:', statistics.stdev(all_tau) / 1000, 'secs')
    print('[Well] Average number of hops:', sum(all_hops) / len(all_hops))
    print('[Well] Average tau:', sum(all_tau) / len(all_tau) / 1000, 'secs')

def traverse_graph(g: nx.Graph, seq) -> tuple[int, int]:
    randomPair = random.sample(seq, 2)  # Two node ids without duplicate
    startNode = randomPair[0]
    endNode = randomPair[1]

    path = nx.shortest_path(g, source=startNode, target=endNode, method='dijkstra')
    return len(list(path)), nx.path_weight(g, path=path, weight='weight')

if __name__ == '__main__':
    main()
