import sys
import pandas as pd
import argparse
import os


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--data', type=str, required=True,
                        help='Data file generated by simulation')
    parser.add_argument('--csv', required=False, action='store_true', dest='csv',
                        help='Output data in csv format for another process')

    args = parser.parse_args()

    # ================= Read metadata =================
    read_config = False
    read_seed = False
    read_blocks = False
    read_block_size = False
    read_miners_honest = False
    read_miners_malicious = False

    blocks = 0
    block_size = 0
    config = ''
    seed = 0
    miners_count = 0

    if not os.path.exists(args.data):
        print('Specified path to data file does not exists', file=sys.stderr)
        exit(1)

    # Cannot directly replace 'data_' because it can be used as name/part of the name of some folder in specified path
    data_prefix_index = args.data.rfind('data_')

    if data_prefix_index == -1:
        print('Invalid data file name', file=sys.stderr)
        exit(1)

    if data_prefix_index == 0:
        # data_...
        metadata_path = args.data.replace('data_', 'metadata_', 1)
    else:
        # {path}/data_...
        metadata_path = '/metadata_'.join(args.data.rsplit('/data_', 1))

    # Replace file extension
    metadata_path = metadata_path[:len(metadata_path) - 3] + 'data'

    if not os.path.exists(metadata_path):
        print(
            f'Metadata file for {args.data} cannot be found', file=sys.stderr)
        exit(1)

    with open(metadata_path, 'r') as metadata_file:
        for row in metadata_file:
            value = row.rstrip('\n')
            if read_config and read_seed and read_blocks and read_block_size and read_miners_honest and read_miners_malicious:
                break

            if value.startswith('cfg_path='):
                config = value[len('cfg_path='):]
                read_config = True
            elif value.startswith('seed='):
                seed = int(value[len('seed='):])
                read_seed = True
            elif value.startswith('blocks='):
                blocks = int(value[len('blocks='):])
                read_blocks = True
            elif value.startswith('block_size='):
                block_size = int(value[len('block_size='):])
                read_block_size = True
            elif value.startswith('malicious_miners='):
                miners_count += int(value[len('malicious_miners='):])
                read_miners_malicious = True
            elif value.startswith('honest_miners='):
                miners_count += int(value[len('honest_miners='):])
                read_miners_honest = True

    if not read_config:
        print(f'Metadata does not contain config path', file=sys.stderr)
        exit(1)

    if not read_seed:
        print(f'Metadata does not contain seed', file=sys.stderr)
        exit(1)

    if not read_blocks:
        print(f'Metadata does not contain number of blocks', file=sys.stderr)
        exit(1)

    if not read_block_size:
        print(f'Metadata does not contain block size', file=sys.stderr)
        exit(1)

    # =================================================

    malicious_miners_indexes = parse_config(config)

    tx_count = blocks * block_size

    miners_profit = [0] * miners_count

    # Store total profit gained in simulation by all miners for next calculations
    total_profit = 0

    # Store transaction ids of all processed transactions
    processed_tx = {}

    df = pd.read_csv(args.data)

    for i in range(0, tx_count):
        tx_id = df['TransactionID'][i]
        if tx_id not in processed_tx:
            minerId = df['MinerID'][i]
            miners_profit[minerId] += df['Fee'][i]
            total_profit += df['Fee'][i]
            processed_tx[tx_id] = None  # Mark transaction as processed

    malicious_miners_perc_profit = 0

    # Count total malicious profit
    for i in range(len(malicious_miners_indexes)):
        miner_perc_profit = round(
            miners_profit[malicious_miners_indexes[i]] / total_profit * 100, 4)
        malicious_miners_perc_profit += miner_perc_profit

    if not args.csv:
        print(f'Data: {args.data}')
        print(f'Config: {config}')
        print(f'Seed: {seed}')

        print(
            f'Honest miners profit: {round(100 - malicious_miners_perc_profit, 2)}%')

        for i in range(len(malicious_miners_indexes)):
            miner_perc_profit = round(
                miners_profit[malicious_miners_indexes[i]] / total_profit * 100, 2)
            print(f'Malicious miner #{i} profit: {miner_perc_profit}%')
    else:
        # Output format: (each value is only in percentage format)
        # {data_path},{config_path},{seed},{honest_miners_perc_profit}{malicious_miner[0]_perc_profit}{malicious_miner[1]_perc_profit}{...}
        #
        # Example:
        # outputs/data_mining_topo.cfg_0000.csv,mining_topo.cfg,512,28.8292,35.0043,36.1665
        print(
            f'{args.data},{config},{seed},{round(100 - malicious_miners_perc_profit, 4)}', end='')

        for i in range(len(malicious_miners_indexes)):
            miner_perc_profit = round(
                miners_profit[malicious_miners_indexes[i]] / total_profit * 100, 4)
            print(f',{miner_perc_profit}', end='')

        print('')   # New line
    return 0


def parse_config(file_path):
    malicious_miners_indexes = []
    with open(file_path, 'r') as file:
        i = 0
        for row in file:
            if row.startswith('biconnect'):
                # Part of config with miners is searched, close config
                break
            if row.startswith('miner'):
                if row.rstrip('\n').split(' ')[1] == 'malicious':
                    malicious_miners_indexes.append(i)
                i += 1

    return malicious_miners_indexes


if __name__ == '__main__':
    main()
