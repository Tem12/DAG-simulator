/**
 * @file ConfigParser.cpp
 * @brief Parse and validate the input configuration file
 * @author Tomas Hladky <xhladk15@stud.fit.vutbr.cz>
 * @author Martin Peresini <iperesini@fit.vut.cz>
 * @date 2021 - 2022
 */

#include "ConfigParser.h"

std::vector<Miner> ConfigParser::parseConfig(Simulation &simulation) const {
	std::ifstream cfgFile(simulation.getConfigPath());

	// Check if specified data file can be opened
	if (!cfgFile.good()) {
		throw std::runtime_error("Cannot open configuration file");
	}

	std::vector<Miner> miners{};
	std::discrete_distribution<> blockPropDelayDistribution(blockPropDelayData);
	double totalMiningPower = 0;

	std::string line;
	while (std::getline(cfgFile, line)) {

		// Skip comments and empty lines
		if (line[0] == '#' || line.empty()) {
			continue;
		}

		size_t sepPos = line.find('=', 0);
		if (sepPos == std::string::npos) {
			throw std::runtime_error("Invalid configuration file structure");
		}

		std::string name = line.substr(0, sepPos);
		std::string value = line.substr(sepPos + 1);

		// Convert string line to individual tokens separated by space
		std::istringstream stringStream(value);
		std::vector<std::string> tokens{std::istream_iterator<std::string>{stringStream},
		                                std::istream_iterator<std::string>{}};

		if (name == "miner") {
			// Validate number of tokens
			if (tokens.size() != MINER_TOKEN_COUNT) {
				throw std::runtime_error(
						"Invalid configuration file structure - miner contains invalid number of tokens");
			}

			double miningPower;
			MinerType minerType;
			try {
				miningPower = std::stod(tokens[0]);
			} catch (std::exception &e) {
				throw std::runtime_error(
						"Invalid configuration file structure - miner contains invalid mining power");
			}

			if (tokens[1] == "honest") {
				minerType = HONEST;
			}
			else if (tokens[1] == "malicious") {
				minerType = MALICIOUS;
			}
			else {
				throw std::runtime_error(
						"Invalid configuration file structure - miner contains invalid type");
			}

			Miner miner(miningPower, minerType, simulation);
			miners.push_back(miner);

			totalMiningPower += totalMiningPower;
		}
		else if (name == "biconnect") {
			// Validate number of tokens. Last token (connection delay) is optional and if not provided
			// it will be generated by distribution with data from Bitcoin network
			if (tokens.size() != BICONN_TOKEN_COUNT && tokens.size() != BICONN_TOKEN_COUNT + 1) {
				throw std::runtime_error(
						"Invalid configuration file structure - bi-connect contains invalid number of tokens");
			}

			bool generateConnectionDelay = false;

			if (tokens.size() == BICONN_TOKEN_COUNT + 1) {
				generateConnectionDelay = true;
			}

			if (miners.empty()) {
				throw std::runtime_error(
						"Invalid configuration file structure - no miner was defined before bi-connect");
			}

			uint32_t miner1Index;
			uint32_t miner2Index;
			double connectionDelay;

			try {
				miner1Index = std::stoul(tokens[0]);
				miner2Index = std::stoul(tokens[1]);

				if (generateConnectionDelay) {
					connectionDelay = std::stod(tokens[2]);
				}
				else {
					connectionDelay = blockPropDelayDistribution(simulation.getRandomGen());
				}
			}
			catch (std::exception &e) {
				throw std::runtime_error("Invalid configuration file structure - invalid bi-connection");
			}

			if (miner1Index >= miners.size() || miner2Index >= miners.size()) {
				throw std::runtime_error(
						"Invalid configuration file structure - bi-connection contains undefined miner");
			}

			if (connectionDelay < 0) {
				throw std::runtime_error(
						"Invalid configuration file structure - bi-connection contains negative delay");
			}

			// Convert delay from ms to s
			connectionDelay /= 1000;

			miners[miner1Index].addPeer(miners[miner2Index], connectionDelay);
			miners[miner2Index].addPeer(miners[miner1Index], connectionDelay);
		}
	}

	// Summing mining power from all miners produces floating point error.
	// To avoid this, TOTAL_HASHPOWER_EPS contains maximum difference from sum
	if ((totalMiningPower - 1.0 > TOTAL_HASHPOWER_EPS) || (totalMiningPower + 1.0 < TOTAL_HASHPOWER_EPS)) {
		throw std::runtime_error("Hashpower of all miners needs to be 100%");
	}

	return miners;
}
